# Зеркалец

## Описание

В одной далёкой стране был построен город, названный Зеркалец. Он славился своей
уникальной архитектурой: каждый дом с одного берега реки имел точное зеркальное
отражение по другой берег. Туристы стекались сюда, чтобы полюбоваться этой
потрясающей симметрией.

Но однажды прошла беда: сильный шторм разрушил часть города, и зеркальная
симметрия была нарушена. Чтобы вернуть городу его былую славу, нужно было
определить, какая часть города всё ещё осталась зеркально-симметричной. В этом
помогут. Архитекторы обратились к вам за помощью.

## Задача

Считайте с ввода дерево домов и найдите в нём все поддеревья, в которых типы
домов симметричны. Те поддеревья, которые являются поддеревьями для других
найденных поддеревьев, в результат не включаются.

Ввод:

- Первая строка: чётное количество адресов N.
- Последующие N строк вида:
  - трехзначный адрес дома;
  - пробел (` `);
  - тип дома одним словом.

Вывод:

- Записанный в одну строку массив вида:
  - открывающаяся квадратная скобка (`[`);
  - трехзначные адреса результатов, выводимые в порядке обхода в ширину слева
    направо:
    - если адресов несколько, они должны разделяться запятой с пробелом `, `;
  - закрывающаяся квадратная скобка (`]`).

## Тестовые случаи

### 1

- 000: A
  - **001: B**
    - **002: C**
    - **200: C**
  - 100: B
    - **003: D**

Ввод:

```text
6
000 A
001 B
100 B
002 C
200 C
003 D
```

Вывод:

```text
[001, 003]
```

### 2

- 000: A
  - **001: B**
    - **002: D**
    - **200: D**
  - 100: C
    - **003: E**

Ввод:

```text
6
000 A
001 B
100 C
002 D
200 D
003 E
```

Вывод:

```text
[001, 003]
```

### 3

- 000: House
  - **001: Store**
  - **100: Дом**

Ввод:

```text
3
100 House
000 House
001 Store
```

Вывод:

```text
[001, 100]
```

### 4

- **000: X**
  - **001: Y**
    - **002: Z**
    - **200: Z**
  - **100: Y**
    - **003: W**
    - **300: W**

Ввод:

```text
6
000 X
001 Y
100 Y
002 Z
200 Z
003 W
300 W
```

Вывод:

```text
[000]
```

### 5

- 000: P
  - 001: Q
    - 002: R
      - **004: T**
    - **200: R**
  - **100: Q**
    - **003: S**
    - **300: S**

Ввод:

```text
8
000 P
001 Q
100 Q
002 R
200 R
003 S
300 S
004 T
```

Вывод:

```text
[100, 200, 004]
```

### 6

- null

Ввод:

```text
0
```

Вывод:

```text
[]
```

### 7

- 000: M
  - **001: K**
    - **002: M**
    - **200: M**
  - **100: N**
    - **003: N**
    - **300: N**

Ввод:

```text
7
300 N
003 N
001 K
000 M
100 N
200 M
002 M
```

Вывод:

```text
[001, 100]
```

### 8

- 000: A
  - 001: B
    - 002: A
      - **004: C**
    - **200: A**
  - 100: B
    - **003: C**
    - **300: A**

Ввод:

```text
8
100 B
000 A
300 A
002 A
003 C
001 B
004 C
200 A
```

Вывод:

```text
[200, 003, 300, 004]
```

### 9

- 000: A
  - **001: B**
  - 100: A
    - **300: N**

Ввод:

```text
4
300 N
100 A
000 A
001 B
```

Вывод:

```text
[001, 300]
```

### 10

- 000: R
  - 001: S
    - 002: T
      - 004: V
        - **008: V**
    - **200: T**
  - **100: S**
    - **003: U**
    - **300: U**

Ввод:

```text
10
008 V
004 V
300 U
003 U
200 T
002 T
100 S
001 S
000 R
```

Вывод:

```text
[100, 200, 008]
```

## Теория

### Структуры данных

#### Деревья

Дерево — это иерархическая структура данных, состоящая из узлов, где:

- Один узел является корнем.
- Каждый узел может иметь несколько потомков, но только одного родителя (кроме корня).

Обычно используется для представления и обработки данных, которые имеют
иерархическую природу, например, файловая система, семейное древо или структура
каталога. Часто применяется в алгоритмах поиска и сортировки.

---

##### Дерево на массиве

В представлении дерева через массив каждому узлу присваивается индекс, а связи
между узлами определяются математическими формулами:

- Для узла с индексом $i$:
  - Левый потомок: $2i + 1$.
  - Правый потомок: $2i + 2$.
  - Родитель: $\lfloor (i - 1) / 2 \rfloor$.

Для данной задачи требуется дерево с двумя методами:

1. **Добавление**
   - Узлы добавляются последовательно.
   - Связи автоматически определяются индексами.

2. **Поиск**:
   - Доступ к узлу осуществляется напрямую по индексу.
   - Для проверки симметрии можно легко определить потомков и их свойства.

Преимущества:

- Легко обрабатывать и проверять поддеревья благодаря доступу по индексам.
- Подходит, если дерево изначально задано в виде массива.
- Подходит для данной задачи, так как количество элементов заранее известно.

---

##### Дерево на указателях

В представлении дерева через указатели каждый узел содержит ссылки на свои потомки:

- Узел представлен как объект или структура с полями:
  - Значение узла.
  - Указатель на левый потомок.
  - Указатель на правый потомок.

Для данной задачи требуется дерево с двумя методами:

1. **Добавление**
   - Узлы добавляются через рекурсивный или итеративный проход, начиная с корня.
   - Новые узлы добавляются в первое подходящее свободное место.

2. **Поиск**
   - Для доступа к узлу требуется проходить дерево, начиная с корня.

Преимущества:

- Удобно работать с рекурсией при проверке симметрии поддеревьев.
- Подходит для деревьев с динамическим размером.
- Подходит для любой задачи, требующей деревья.

---

### Алгоритм

#### Общий алгоритм решения

1. Считываем дерево из входных данных.
2. Строим его в одном из представлений (на массиве или указателях).
3. Проверяем симметричность поддеревьев:
   - Для каждого узла проверяем симметрию его поддерева.
   - Используем рекурсию, BFS, хэширование или другие методы.
4. Исключаем вложенные поддеревья (если требуется).
5. Выводим адреса корней симметричных поддеревьев.

---

#### Вариант №1: Рекурсивная проверка симметрии

- **Сложность**: $O(N^2)$.
- **Описание**: Для каждого узла проверяем, является ли его поддерево
  симметричным, через рекурсию.

1. Обходим дерево в глубину.
2. Для каждого узла вызываем функцию проверки симметрии, которая:
   - Сравнивает левое и правое поддеревья.
   - Рекурсивно вызывает себя для потомков.
3. Если поддерево симметрично, добавляем узел в список.
4. Упорядочиваем найденные узлы.

Преимущества:

- Простота реализации.

Недостатки:

- Низкая производительность на больших деревьях.

---

#### Вариант №2: Динамическое программирование

- **Сложность**: $O(N)$.
- **Описание**: Используем сохранение результатов проверки для повторного
  использования.

1. Обрабатываем дерево снизу вверх.
2. Для каждого узла определяем, симметрично ли его поддерево, на основе
   результатов проверки потомков.
3. Если узел симметричен, записываем его.

Преимущества:

- Высокая производительность.

Недостатки:

- Сложность реализации.

---

#### Вариант №3: Итеративный обход дерева (BFS)

- **Сложность**: $O(N \cdot H)$.
- **Описание**: Обходим дерево в ширину, используя очередь для проверки
  симметрии.

1. Добавляем корень дерева в очередь.
2. Для каждого узла:
   - Проверяем симметричность потомков.
   - Если узел симметричен, добавляем в результат.
   - Добавляем потомков в очередь.
3. Повторяем до обработки всех узлов.

Преимущества:

- Подходит для неглубоких деревьев.

Недостатки:

- Низкая производительность на деревьях большой высоты.

---

#### Вариант №4: Хэширование поддеревьев

- **Сложность**: $O(N)$.
- **Описание**: Каждое поддерево представляем в виде строки и хэшируем.

1. Для каждого узла генерируем строковое представление поддерева.
2. Проверяем, совпадают ли хэши зеркальных поддеревьев.
3. Если совпадают, добавляем узел в список.

Преимущества:

- Высокая скорость выполнения.

Недостатки:

- Требует дополнительной памяти для хранения хэшей.

---

#### Вариант №5: Уникальные идентификаторы

- **Сложность**: $O(N \cdot H)$.
- **Описание**: Используем идентификаторы для проверки симметрии.

1. Присваиваем каждому узлу уникальный идентификатор.
2. Для каждого узла проверяем последовательности идентификаторов зеркальных поддеревьев.
3. Если идентификаторы совпадают, узел симметричен.

Преимущества:

- Простота сравнения.

Недостатки:

- Увеличенное потребление памяти.

---

### Заключение

Для задачи проверки симметрии поддеревьев наиболее подходящим методом будет
выбор между динамическим программированием и хэшированием:

- Динамическое программирование эффективно для всех деревьев.
- Хэширование быстрее в большинстве случаев, но требует дополнительной памяти.
- Выбор зависит от ограничения по памяти и размера дерева.
